/*
 * generated by Xtext
 */
package org.kulto.formatting

import java.util.List
import java.util.Set
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter
import org.eclipse.xtext.formatting.impl.FormattingConfig
import org.kulto.services.KultoDslGrammarAccess

// import com.google.inject.Inject;
// import samvyk.services.SamVykDslGrammarAccess
/**
 * This class contains custom formatting description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#formatting
 * on how and when to use it
 * 
 * Also see {@link org.eclipse.xtext.xtext.XtextFormattingTokenSerializer} as an example
 */
class KultoDslFormatter extends AbstractDeclarativeFormatter {

	KultoDslGrammarAccess ga

	override protected void configureFormatting(FormattingConfig c) {

		ga = grammarAccess as KultoDslGrammarAccess

		c.setAutoLinewrap(180)
		config.genericFormatting
		config.focusedFormatting
	}

	/**
	 * In your implementation of
	 * {@link AbstractDeclarativeFormatter#configureFormatting(org.eclipse.xtext.formatting.impl.FormattingConfig)}
	 * you may call this generic formatting method first. It indents blocks
	 * between curly braces and sets a linewrap before each keyword. Add your
	 * own behavior afterwards, e.g.
	 * 
	 * <pre>
	 *   keywords = grammar.findKeywords(...)
	 *   for (final Keyword keyword : keywords) {
	 *    config.setNoLinewrap().before(keyword)
	 *   }
	 * </pre>
	 */
	def void genericFormatting(FormattingConfig it) {

		for (pair : grammar.findKeywordPairs("{", "}")) {

			// a space before the first '{'
			setSpace(" ").before(pair.getFirst())

			// indentation between
			setIndentation(pair.getFirst(), pair.getSecond())

			// linewrap before first '{'
			setLinewrap(1, 2, 2).after(pair.first)

			// and a linewrap before the last '}'
			setLinewrap(1).before(pair.second)
		}

		// linewrap before all keywords
		val Set<String> allKeywords = GrammarUtil::getAllKeywords(grammar.getGrammar())
		val List<Keyword> keywords = grammar.findKeywords(allKeywords.toArray(newArrayOfSize(allKeywords.size)))
		for (keyword : keywords) {
			setLinewrap().before(keyword)
		}

		// It's usually a good idea to activate the following three statements.
		// They will add and preserve newlines around comments
		setLinewrap(0, 0, 1).before(ga.getSL_COMMENTRule())
		setLinewrap(0, 1, 2).before(ga.getML_COMMENTRule())
		setLinewrap(0, 1, 1).after(ga.getML_COMMENTRule())
	}

	def void focusedFormatting(FormattingConfig it) {

		// Primitive
		val primitive = ga.primitiveAccess
		setLinewrap(1, 1, 2).before(primitive.primitiveKeyword_0)
		setNoLinewrap.before(primitive.javaKeyword_2)

		// Ennum
		val ennum = ga.ennumAccess
		setLinewrap(1, 1, 2).before(ennum.enumKeyword_0)

		// EnnumLiteral
		val ennumLiteral = ga.ennumLiteralAccess
		setLinewrap(1, 1, 2).before(ennumLiteral.nameAssignment_0)
		setNoLinewrap.before(ennumLiteral.popisAssignment_1)

		// Entity
		val entity = ga.entityAccess
		setLinewrap(1, 1, 2).before(entity.entityKeyword_0)
		setLinewrap(1, 1, 2).before(entity.popisPopisParserRuleCall_4_0)

		// Attribute
		val attribute = ga.attributeAccess
		setLinewrap(1, 1, 2).before(attribute.atrKeyword_0)
		setNoLinewrap.before(attribute.manyAsteriskKeyword_3_0)
		setNoLinewrap.before(attribute.popisAssignment_4)

		// Application
		val application = ga.applicationAccess
		setLinewrap(1, 1, 2).before(application.applicationKeyword_0)
		setNoLinewrap.before(application.commaKeyword_4_0)
		setNoSpace.before(application.commaKeyword_4_0)

		// Popis
		val popis = ga.popisAccess
		setLinewrap(1, 1, 2).before(popis.popisKeyword_0)

	}

}
